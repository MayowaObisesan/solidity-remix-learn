/**
 *Submitted for verification at PolygonScan.com on 2023-09-01
*/

/** 
 *  SourceUnit: /run/media/null/EXT/web3lagos23_ctf/src/Challenge1.sol
*/
            
// SPDX-License-Identifier: UNLICENSED
interface S_M {
    // ##################################################################
    // ##################################################################
    // ##################################################################
    // ##################################################################
    // ########              ##########  ######  ##              ########
    // ########  ##########  ##  ##  ####  ##  ####  ##########  ########
    // ########  ##      ##  ##########  ##  ##  ##  ##      ##  ########
    // ########  ##      ##  ##      ####    ######  ##      ##  ########
    // ########  ##      ##  ####  ##  ##  ########  ##      ##  ########
    // ########  ##########  ##    ######      ####  ##########  ########
    // ########              ##  ##  ##  ##  ##  ##              ########
    // ##########################      ####  ##  ########################
    // ########          ##        ######    ####  ##  ##  ##  ##########
    // ########    ##    ####    ##  ####  ####  ####  ######  ##########
    // ########  ##            ####  ######      ##  ####  ##    ########
    // ########    ##  ######  ######    ##    ##    ##########  ########
    // ##########  ##        ##      ####  ######        ##      ########
    // ########  ####  ##  ######  ##      ####    ##  ##  ##  ##########
    // ########  ##  ######    ########        ####        ##    ########
    // ########  ######  ######        ####  ####  ##    ######  ########
    // ########  ######  ##    ##  ####                  ##  ############
    // ########################      ####  ##    ######    ##############
    // ########              ##    ####  ######  ##  ##  ##      ########
    // ########  ##########  ####    ##  ######  ######    ##    ########
    // ########  ##      ##  ##  ####  ##                ##    ##########
    // ########  ##      ##  ##  ##  ############    ##          ########
    // ########  ##      ##  ##  ##  ##      ####  ######    ##  ########
    // ########  ##########  ##  ####    ####              ####  ########
    // ########              ##  ######      ######              ########
    // ##################################################################
    // ##################################################################
    // ##################################################################
    // ##################################################################

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #
    // #

    // #
    // #

    // ##

    // ###

    // #
    // #
    // #

    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #
    // #

    // #
    // #

    // ##

    // ###

    // #
    // #
    // #

    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #
    // #

    // #
    // #

    // ##

    // ###

    // #
    // #
    // #

    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #
    // #

    // #
    // #

    // ##

    // ###

    // #
    // #
    // #

    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #
    // #

    // #
    // #

    // ##

    // ###

    // #
    // #
    // #

    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #
    // #

    // #
    // #

    // ##

    // ###

    // #
    // #
    // #

    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #

    // #
    // #
    // #
    // #

    // #
    // #
    // #
    // #

    // #
    // #

    // #
    // #

    // ##

    // ###

    // #
    // #
    // #

    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #
    // #

    struct MSS_SS_SSM {
        uint8 offset__0;
        uint8 offset__1;
        uint8 offset__2;
        uint8 offset__3;
        uint8 offset__4;
        uint8 offset__5;
        uint8 offset__6;
        uint8 offset__7;
        uint64 offset2_8;
        uint64 offset2_9;
        uint16 __boom__;
        uint48 offset2_10;
    }

    function __expected__() external view returns (MSS_SS_SSM memory);
}


/** 
 *  SourceUnit: /run/media/null/EXT/web3lagos23_ctf/src/Challenge1.sol
*/

////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: UNLICENSED
pragma solidity ^0.8.13;
////import {S_M} from "./sec_ret__miss_ive.sol";

contract W_3_B_C_1 is S_M {
    //                                       .--,-``-.
    //            .---.                     /   /     '.    ,--,                                                             ,----,      ,----..
    //           /. ./|            ,---,   / ../        ; ,--.'|                                                           .'   .' \    /   /   \
    //       .--'.  ' ;          ,---.'|   \ ``\  .`-    '|  | :                            ,---.                        ,----,'    |  /   .     :
    //      /__./ \ : |          |   | :    \___\/   \   ::  : '                ,----._,.  '   ,'\   .--.--.             |    :  .  ; .   /   ;.  \
    //  .--'.  '   \' .   ,---.  :   : :         \   :   ||  ' |     ,--.--.   /   /  ' / /   /   | /  /    '            ;    |.'  / .   ;   /  ` ;
    // /___/ \ |    ' '  /     \ :     |,-.      /  /   / '  | |    /       \ |   :     |.   ; ,. :|  :  /`./            `----'/  ;  ;   |  ; \ ; |
    // ;   \  \;      : /    /  ||   : '  |      \  \   \ |  | :   .--.  .-. ||   | .\  .'   | |: :|  :  ;_                /  ;  /   |   :  | ; | '
    //  \   ;  `      |.    ' / ||   |  / :  ___ /   :   |'  : |__  \__\/: . ..   ; ';  |'   | .; : \  \    `.            ;  /  /-,  .   |  ' ' ' :
    //   .   \    .\  ;'   ;   /|'   : |: | /   /\   /   :|  | '.'| ," .--.; |'   .   . ||   :    |  `----.   \          /  /  /.`|  '   ;  \; /  |
    //    \   \   ' \ |'   |  / ||   | '/ :/ ,,/  ',-    .;  :    ;/  /  ,.  | `---`-'| | \   \  /  /  /`--'  /        ./__;      :___\   \  ',  /
    //     :   '  |--" |   :    ||   :    |\ ''\        ; |  ,   /;  :   .'   \.'__/\_: |  `----'  '--'.     /         |   :    .'/  .\;   :    /
    //      \   \ ;     \   \  / /    \  /  \   \     .'   ---`-' |  ,     .-./|   :    :            `--'---'          ;   | .'   \  ; |\   \ .'
    //       '---"       `----'  `-'----'    `--`-,,-'             `--`---'     \   \  /                               `---'       `--"  `---`

    //Levels
    bytes constant DOOR = (abi.encodePacked("Door"));
    bytes constant LEVEL_A = (abi.encodePacked("Level A"));
    bytes constant LEVEL_B = (abi.encodePacked("Level B"));
    bytes constant LEVEL_C = (abi.encodePacked("Level C"));
    bytes constant LEVEL_D = (abi.encodePacked("Level D"));

    mapping(address => mapping(bytes => bool)) public levels;
    mapping(bytes => bool) public unlocked;

    uint256 constant door$initial = 180 ether;
    uint256 constant grandLevels = 360 ether;

    error LevelNotPassed(string);

    //master and auth
    mapping(address => bool) public validPlayer;
    //nick and address
    mapping(address => string) nicks;
    //door
    mapping(bytes32 => bool) private validkey;
    mapping(bytes32 => bool) public usedkey;

    //level B
    mapping(address => uint) public trustCount;

    //level D
    mapping(address => address) public registeredProxies;
    bool public paused;

    event DoorUnlocked(string opener, string key, uint256 timeFired);
    event LevelUnlocked(string opener, string level, uint256 timeFired);
    event MasterLevelUnlocked(string opener, string level, uint256 timeFired);
    event PrincipalChanged(
        string culprit,
        address newPrincipal,
        uint256 timeFired
    );
    event ProxyRegistered(string registrar, address proxy, uint256 timeFired);

    event FirstSolver(string solver, string level, uint256 timeFired);

    address public owner;

    constructor() payable {
        owner = msg.sender;
        paused = true;
    }

    uint256 public CTFStart;

    function open_entrance_door(
        uint16 _magicno,
        string calldata _just_a_name,
        string calldata _secret_missive,
        string calldata _x_
    ) public {
        __checkPausedState();
        __isValidPlayer__();
        __hasNotSolved__(DOOR);
        if (usedkey[sha256(abi.encodePacked(_x_))])
            revert("Idan no dey open different doors with the same key");

        if (
            validkey[
                sha256(
                    abi.encodePacked(
                        _magicno,
                        _just_a_name,
                        _secret_missive,
                        _x_
                    )
                )
            ]
        ) {
            if (!unlocked[DOOR]) {
                unlocked[DOOR] = true;
                //do transfer
                __out__(door$initial);
                emit FirstSolver(
                    toNick(msg.sender),
                    string(DOOR),
                    block.timestamp
                );
            }
            levels[tx.origin][DOOR] = true;
            usedkey[sha256(abi.encodePacked(_x_))] = true;

            emit DoorUnlocked(toNick(tx.origin), _x_, block.timestamp);
        }
    }

    function solve_challenge_A(bytes32 c__) public payable {
        __checkPausedState();
        __isValidPlayer__();
        __hasSolved__(DOOR);
        __hasNotSolved__(LEVEL_A);
        address $t$;
        address $o$;
        assembly {
            $t$ := caller()
        }
        assembly {
            $o$ := origin()
        }
        require(
            msg.value == (uint32(uint160($t$)) & 0xffff) / 100,
            "Is it for beans?"
        );
        require(
            c__ == keccak256(abi.encode("0x44\\0x33\\0x22\\0x11\\0x00", $o$)),
            "Is it for garri"
        );

        if (!unlocked[LEVEL_A]) {
            unlocked[LEVEL_A] = true;
            //do transfer
            __out__(door$initial);
            emit FirstSolver(
                toNick(tx.origin),
                string(LEVEL_A),
                block.timestamp
            );
        }
        levels[tx.origin][LEVEL_A] = true;
        emit LevelUnlocked(toNick(tx.origin), string(LEVEL_A), block.timestamp);
    }

    event DiSCoNnEcTeD();

    function solve_challenge_B() public {
        __checkPausedState();
        __isValidPlayer__();
        __hasSolved__(LEVEL_A);
        __hasNotSolved__(LEVEL_B);

        if (trustCount[msg.sender] != 0) {
            //short-circuit and revert slot
            trustCount[msg.sender] = 0;
            emit DiSCoNnEcTeD();
        }
        (bool result, ) = msg.sender.call("");
        if (result) {
            trustCount[msg.sender]++;
            if (
                trustCount[msg.sender] ==
                uint8(uint256(keccak256("solved"))) % 15
            ) {
                if (!unlocked[LEVEL_B]) {
                    unlocked[LEVEL_B] = true;
                    //do transfer
                    __out__(grandLevels);
                    emit FirstSolver(
                        toNick(tx.origin),
                        string(LEVEL_B),
                        block.timestamp
                    );
                }
                levels[tx.origin][LEVEL_B] = true;
                emit MasterLevelUnlocked(
                    toNick(tx.origin),
                    string(LEVEL_B),
                    block.timestamp
                );
            }
        }
    }

    address currentPrincipal;

    function solve_challenge_C(address _newPrincipal) public {
        __checkPausedState();
        __isValidPlayer__();
        if (tx.origin != msg.sender) {
            if (_newPrincipal.code.length > 0)
                revert("Idan no suppose get code");
            currentPrincipal = _newPrincipal;
            emit PrincipalChanged(
                toNick(tx.origin),
                _newPrincipal,
                block.timestamp
            );
        }
    }

    function get_C_Profit() public {
        __isValidPlayer__();
        __hasSolved__(DOOR);
        __hasNotSolved__(LEVEL_C);
        if (tx.origin != currentPrincipal) revert("Not Principal");
        if (!unlocked[LEVEL_C]) {
            unlocked[LEVEL_C] = true;
            __out__(door$initial);
            emit FirstSolver(
                toNick(msg.sender),
                string(LEVEL_C),
                block.timestamp
            );
        }

        levels[tx.origin][LEVEL_C] = true;
        emit LevelUnlocked(
            toNick(msg.sender),
            string(LEVEL_C),
            block.timestamp
        );
    }

    function solve_challenge_D(address _proxy) public {
        __checkPausedState();
        __isValidPlayer__();
        __hasSolved__(LEVEL_C);
        if (_proxy.code.length > 0) revert("PROXIES MUST NOT CONTAIN CODE");
        //register proxy for user
        registeredProxies[tx.origin] = _proxy;
        emit ProxyRegistered(toNick(tx.origin), _proxy, block.timestamp);
    }

    function solve_challenge_D2() public {
        __isValidPlayer__();
        __hasSolved__(LEVEL_C);
        __hasNotSolved__(LEVEL_D);
        assert(registeredProxies[tx.origin] != address(0));
        if (registeredProxies[tx.origin].code.length == 0)
            revert("PROXIES SHOULD CONTAIN CODE");
        assert(
            S_M(registeredProxies[tx.origin]).__expected__().__boom__ ==
                uint16(
                    bytes2(
                        bytes16(
                            keccak256(abi.encode(registeredProxies[tx.origin]))
                        )
                    )
                )
        );
        if (!unlocked[LEVEL_D]) {
            unlocked[LEVEL_D] = true;
            __out__(grandLevels);
            emit FirstSolver(
                toNick(msg.sender),
                string(LEVEL_D),
                block.timestamp
            );
        }

        levels[tx.origin][LEVEL_D] = true;
        emit LevelUnlocked(
            toNick(msg.sender),
            string(LEVEL_D),
            block.timestamp
        );
    }

    //checks
    function __hasSolved__(bytes memory _level) public view {
        string memory level = string(_level);
        if (!levels[tx.origin][_level]) revert LevelNotPassed(level);
    }

    function __hasNotSolved__(bytes memory _level) public view {
        if (levels[tx.origin][_level]) revert("LevelPassed");
    }

    function __isOwner__() public view {
        if (msg.sender != owner) revert("Not owner");
    }

    function __isValidPlayer__() public view {
        if (!validPlayer[tx.origin]) revert("Not a valid player");
    }

    //out
    function __out__(uint256 _amount) private {
        payable(tx.origin).transfer(_amount);
    }

    function togglePause() public {
        __isOwner__();
        paused = !paused;
        CTFStart = block.timestamp;
    }

    function __checkPausedState() public view {
        if (paused) revert("Paused");
    }

    receive() external payable {}

    ///ADMIN
    //register players
    function massW(
        address[] calldata hackers,
        string[] calldata _hackers
    ) public {
        __isOwner__();
        for (uint i = 0; i < hackers.length; i++) {
            validPlayer[hackers[i]] = true;
            nicks[hackers[i]] = _hackers[i];
        }
    }

    function toNick(address _addr) public view returns (string memory) {
        return nicks[_addr];
    }

    //register keys
    function massH(bytes32[] calldata keys) public {
        for (uint i = 0; i < keys.length; i++) {
            validkey[keys[i]] = true;
        }
    }

    function __out__x() public {
        __isOwner__();
        payable(owner).transfer(address(this).balance);
    }

    //     .
    //     .
    //     .
    //     .
    //     .
    //     .
    //     .
    //     .
    //     .
    //     .
    //     .
    // .
    //     .
    //     .
    //     .
    //     .

    //     .
    //     .
    //     .
    //     .
    //     .
    // .
    //     .
    //     .

    function __expected__() external pure returns (MSS_SS_SSM memory) {}
}